import .homotopy

universes u v

open categories
open categories.category
local notation f ` ‚àò `:80 g:80 := g ‚â´ f

namespace homotopy_theory.cofibrations
open precofibration_category -- cofibration_category

variables {C : Type u} [cat : category.{u v} C] [cofibration_category.{u v} C]
include cat

-- Tracks, or "homotopies up to homotopy". This notion is a bit tricky
-- because there is no canonical choice of cylinder object on which to
-- define homotopies. Instead, we define an equivalence relation
-- between homotopies defined on different cylinder objects and define
-- a track to be an equivalence class, and then show that every
-- cylinder object admits a unique homotopy class of homotopies
-- representing each track.

variables {a b : C} {j : a ‚ü∂ b} (hj : is_cof j)
variables {x : C}
variables (f‚ÇÄ f‚ÇÅ : b ‚ü∂ x)

structure homotopy :=
(c : relative_cylinder hj)
(h : homotopy_on c f‚ÇÄ f‚ÇÅ)

variables {hj f‚ÇÄ f‚ÇÅ}
-- An extension of homotopies. These are like acyclic cofibrations in
-- a category of objects under b ‚äî‚Çê b and over b and x, where the
-- compositions b ‚äî‚Çê b ‚Üí b and b ‚äî‚Çê b ‚Üí x are given by the fold map
-- and (f‚ÇÄ, f‚ÇÅ) respectively.
structure homotopy_extension (t t' : homotopy hj f‚ÇÄ f‚ÇÅ) :=
(m : cylinder_embedding t.c t'.c)
(e : t'.h.H ‚àò m.k = t.h.H)

def homotopy_extension.refl (t : homotopy hj f‚ÇÄ f‚ÇÅ) : homotopy_extension t t :=
‚ü®cylinder_embedding.refl t.c, show _ ‚àò ùüô _ = _, by simp‚ü©

def homotopy_extension.trans {t‚ÇÄ t‚ÇÅ t‚ÇÇ : homotopy hj f‚ÇÄ f‚ÇÅ}
  (m‚ÇÄ : homotopy_extension t‚ÇÄ t‚ÇÅ) (m‚ÇÅ : homotopy_extension t‚ÇÅ t‚ÇÇ) :
  homotopy_extension t‚ÇÄ t‚ÇÇ :=
‚ü®m‚ÇÄ.m.trans m‚ÇÅ.m,
 by dsimp [cylinder_embedding.trans]; rw [associativity, m‚ÇÅ.e, m‚ÇÄ.e]‚ü©

def homotopy_extension.pushout {t t‚ÇÄ t‚ÇÅ : homotopy hj f‚ÇÄ f‚ÇÅ}
  (m‚ÇÄ : homotopy_extension t t‚ÇÄ) (m‚ÇÅ : homotopy_extension t t‚ÇÅ) :
  homotopy hj f‚ÇÄ f‚ÇÅ :=
‚ü®cylinder_embedding.pushout m‚ÇÄ.m m‚ÇÅ.m,
 ‚ü®(cylinder_embedding.pushout.is_pushout m‚ÇÄ.m m‚ÇÅ.m).induced t‚ÇÄ.h.H t‚ÇÅ.h.H
    (by rw [m‚ÇÄ.e, m‚ÇÅ.e]),
  begin
    convert t‚ÇÅ.h.Hi‚ÇÄ using 1, unfold relative_cylinder.i‚ÇÄ,
    dsimp [cylinder_embedding.pushout], simp
  end,
  begin
    convert t‚ÇÅ.h.Hi‚ÇÅ using 1, unfold relative_cylinder.i‚ÇÅ,
    dsimp [cylinder_embedding.pushout], simp
  end‚ü©‚ü©

def homotopy_extension.pushout.map‚ÇÄ {t t‚ÇÄ t‚ÇÅ : homotopy hj f‚ÇÄ f‚ÇÅ}
  (m‚ÇÄ : homotopy_extension t t‚ÇÄ) (m‚ÇÅ : homotopy_extension t t‚ÇÅ) :
  homotopy_extension t‚ÇÄ (homotopy_extension.pushout m‚ÇÄ m‚ÇÅ) :=
‚ü®cylinder_embedding.pushout.map‚ÇÄ m‚ÇÄ.m m‚ÇÅ.m,
 by dsimp [cylinder_embedding.pushout.map‚ÇÄ, homotopy_extension.pushout]; simp‚ü©

def homotopy_extension.pushout.map‚ÇÅ {t t‚ÇÄ t‚ÇÅ : homotopy hj f‚ÇÄ f‚ÇÅ}
  (m‚ÇÄ : homotopy_extension t t‚ÇÄ) (m‚ÇÅ : homotopy_extension t t‚ÇÅ) :
  homotopy_extension t‚ÇÅ (homotopy_extension.pushout m‚ÇÄ m‚ÇÅ) :=
‚ü®cylinder_embedding.pushout.map‚ÇÅ m‚ÇÄ.m m‚ÇÅ.m,
 by dsimp [cylinder_embedding.pushout.map‚ÇÅ, homotopy_extension.pushout]; simp‚ü©

-- Two homotopies are equivalent if they have a common extension.
def homotopy_equiv (t‚ÇÄ t‚ÇÅ : homotopy hj f‚ÇÄ f‚ÇÅ) : Prop :=
‚àÉ t' (m‚ÇÄ : homotopy_extension t‚ÇÄ t') (m‚ÇÅ : homotopy_extension t‚ÇÅ t'), true

-- Homotopy equivalence is an equivalence relation.
lemma homotopy_equiv.refl (t : homotopy hj f‚ÇÄ f‚ÇÅ) : homotopy_equiv t t :=
‚ü®t, homotopy_extension.refl t, homotopy_extension.refl t, ‚ü®‚ü©‚ü©

lemma homotopy_equiv.symm {t‚ÇÄ t‚ÇÅ : homotopy hj f‚ÇÄ f‚ÇÅ} :
  homotopy_equiv t‚ÇÄ t‚ÇÅ ‚Üí homotopy_equiv t‚ÇÅ t‚ÇÄ :=
assume ‚ü®t', m‚ÇÄ, m‚ÇÅ, ‚ü®‚ü©‚ü©, ‚ü®t', m‚ÇÅ, m‚ÇÄ, ‚ü®‚ü©‚ü©

lemma homotopy_equiv.trans {t‚ÇÄ t‚ÇÅ t‚ÇÇ : homotopy hj f‚ÇÄ f‚ÇÅ} :
  homotopy_equiv t‚ÇÄ t‚ÇÅ ‚Üí homotopy_equiv t‚ÇÅ t‚ÇÇ ‚Üí homotopy_equiv t‚ÇÄ t‚ÇÇ :=
assume ‚ü®t, m‚ÇÄ, m‚ÇÅ, ‚ü®‚ü©‚ü© ‚ü®t', m‚ÇÅ', m‚ÇÇ', ‚ü®‚ü©‚ü©,
‚ü®m‚ÇÅ.pushout m‚ÇÅ',
 m‚ÇÄ.trans (homotopy_extension.pushout.map‚ÇÄ m‚ÇÅ m‚ÇÅ'),
 m‚ÇÇ'.trans (homotopy_extension.pushout.map‚ÇÅ m‚ÇÅ m‚ÇÅ'),
 ‚ü®‚ü©‚ü©

instance homotopy_equiv.setoid : setoid (homotopy hj f‚ÇÄ f‚ÇÅ) :=
{ r := homotopy_equiv,
  iseqv :=
    ‚ü®Œª t, homotopy_equiv.refl t,
     Œª t‚ÇÄ t‚ÇÅ, homotopy_equiv.symm,
     Œª t‚ÇÄ t‚ÇÅ t‚ÇÇ, homotopy_equiv.trans‚ü© }

variables (hj f‚ÇÄ f‚ÇÅ)
def track := quotient (homotopy_equiv.setoid : setoid (homotopy hj f‚ÇÄ f‚ÇÅ))

variables {hj f‚ÇÄ f‚ÇÅ}
noncomputable def track.refl (f : b ‚ü∂ x) : track hj f f :=
‚ü¶‚ü®classical.choice (exists_relative_cylinder hj), homotopy_on.refl f‚ü©‚üß

lemma track.refl_eq {f : b ‚ü∂ x} (c : relative_cylinder hj) :
  (track.refl f : track hj f f) = ‚ü¶‚ü®c, homotopy_on.refl f‚ü©‚üß :=
quot.sound $
  let c‚ÇÄ := classical.choice (exists_relative_cylinder hj),
      ‚ü®c', m‚ÇÄ, m‚ÇÅ, ‚ü®‚ü©‚ü© := exists_common_embedding c‚ÇÄ c in
  ‚ü®‚ü®c', homotopy_on.refl f‚ü©,
   ‚ü®m‚ÇÄ, show f ‚àò c'.p ‚àò m‚ÇÄ.k = f ‚àò c‚ÇÄ.p, by rw [‚Üêassociativity, m‚ÇÄ.hpk]‚ü©,
   ‚ü®m‚ÇÅ, show f ‚àò c'.p ‚àò m‚ÇÅ.k = f ‚àò c.p, by rw [‚Üêassociativity, m‚ÇÅ.hpk]‚ü©, ‚ü®‚ü©‚ü©

local attribute [elab_with_expected_type] quotient.lift_on quotient.lift_on‚ÇÇ

def track.symm {f‚ÇÄ f‚ÇÅ : b ‚ü∂ x} : track hj f‚ÇÄ f‚ÇÅ ‚Üí track hj f‚ÇÅ f‚ÇÄ :=
Œª t, quotient.lift_on t
  (Œª t, ‚ü¶‚ü®t.c.reverse, t.h.symm‚ü©‚üß)
  (assume t t' ‚ü®t'', m‚ÇÄ, m‚ÇÅ, ‚ü®‚ü©‚ü©, quotient.sound $
    ‚ü®‚ü®t''.c.reverse, t''.h.symm‚ü©, ‚ü®m‚ÇÄ.m.reverse, m‚ÇÄ.e‚ü©, ‚ü®m‚ÇÅ.m.reverse, m‚ÇÅ.e‚ü©, ‚ü®‚ü©‚ü©)

def track.trans {f‚ÇÄ f‚ÇÅ f‚ÇÇ : b ‚ü∂ x} : track hj f‚ÇÄ f‚ÇÅ ‚Üí track hj f‚ÇÅ f‚ÇÇ ‚Üí track hj f‚ÇÄ f‚ÇÇ :=
Œª t‚ÇÄ t‚ÇÅ, quotient.lift_on‚ÇÇ t‚ÇÄ t‚ÇÅ
  (Œª t‚ÇÄ t‚ÇÅ, ‚ü¶‚ü®t‚ÇÄ.c.glue t‚ÇÅ.c, t‚ÇÄ.h.trans t‚ÇÅ.h‚ü©‚üß)
  (assume t‚ÇÄ t‚ÇÅ t‚ÇÄ' t‚ÇÅ' ‚ü®t‚ÇÄ'', m‚ÇÄ‚ÇÄ, m‚ÇÄ‚ÇÅ, ‚ü®‚ü©‚ü© ‚ü®t‚ÇÅ'', m‚ÇÅ‚ÇÄ, m‚ÇÅ‚ÇÅ, ‚ü®‚ü©‚ü©, quotient.sound $
    ‚ü®‚ü®t‚ÇÄ''.c.glue t‚ÇÅ''.c, t‚ÇÄ''.h.trans t‚ÇÅ''.h‚ü©,
     ‚ü®m‚ÇÄ‚ÇÄ.m.glue m‚ÇÅ‚ÇÄ.m,
      begin
        apply (pushout_by_cof t‚ÇÄ.c.i‚ÇÅ t‚ÇÅ.c.i‚ÇÄ t‚ÇÄ.c.acof_i‚ÇÅ.1).is_pushout.uniqueness;
        dsimp [homotopy_on.trans, cylinder_embedding.glue]; rw ‚Üêassociativity;
        simp [m‚ÇÄ‚ÇÄ.e, m‚ÇÅ‚ÇÄ.e],
      end‚ü©,
     ‚ü®m‚ÇÄ‚ÇÅ.m.glue m‚ÇÅ‚ÇÅ.m,
      begin
        apply (pushout_by_cof t‚ÇÄ'.c.i‚ÇÅ t‚ÇÅ'.c.i‚ÇÄ t‚ÇÄ'.c.acof_i‚ÇÅ.1).is_pushout.uniqueness;
        dsimp [homotopy_on.trans, cylinder_embedding.glue]; rw ‚Üêassociativity;
        simp [m‚ÇÄ‚ÇÅ.e, m‚ÇÅ‚ÇÅ.e],
      end‚ü©, ‚ü®‚ü©‚ü©)

end homotopy_theory.cofibrations
